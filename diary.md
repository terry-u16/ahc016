# AHC016日記

## 1日目（金）

HTTF、開幕……。

<https://twitter.com/terry_u16/status/1591005266845532160>

一足遅れて問題を読む。え、めっちゃくちゃ面白そうな問題。

情報の復元、なるほど……。どうせ最終的には上位陣はほぼ全問正解当たり前で、グラフのサイズを小さくするゲームになりそう。

適当にランダム性に任せてなんやかんやする方針はうまく行かなさそう。誤り訂正と聞いてパッと思い浮かぶのはQRコード。グラフを送る問題だが、2次元白黒画像の上三角行列（？）を送る問題と考えた方が良さそう。

グラフの番号が分からなくなるやつはどうしよう。順列全探索？bitDP？Nが小さい場合はうまく行きそう。Nが大きい場合はちょっと考える必要がある。例えばグラフを一直線に繋いでおくとか？冗長性がないと1エラーで即死するので何重かに繋いでおくか。円形に繋いでおいても良い。どこが起点になるか・どちら向きかが分からないが、誤り訂正パートで起点と向きを全探索して一番それらしいものを選べばなんとかなりそう。

番号を復元するときはビムサでも焼きなましでも。焼きなましの方が良いか。2-optが使えたりする？TSPっぽくも見えてきたな。TSPならbitDPと繋がるのも納得。とはいえ誤り復元でやるならかなり高精度で復元できないと厳しいな。bitDPでいけるならそっちがいいが、それでもビットパターンによっては変な復元になることもありそう。QRコードを真似してマスクをかけ、変なビットパターンにならないようにしてあげる必要もあるかも。

ゲノコンにも通じるところがありそう。あのときも読み取りエラーが含まれていたが、最大カットがうまく行った。今回はエラー率4割とかいう激ヤバテストケースも含まれてくるが、どうなるか……。

どんなテストケースが多く含まれるか考える。テストケースの分布が対数的ではなく一様分布なので、Mやεの大きいケースを狙った方が良さそう。もっとも最終的には全部詰めていく必要がありそうだが。

誤り訂正をちゃんとやるなら[ガロア体](https://static.chunichi.co.jp/chunichi/pages/feature/science/galois_field_in_auto_factory.html)とかちゃんとやるべきだろうけど、一気に理解するにはちょっと重い。例えば1の場合は1をk個、0の場合は0をk個並べるとかでもまあとりあえずは機能しそうで、まずはここからやるか。1が連続すると番号復元パートでうまく行かなくなりそうなので、(i+j) mod 2とかで市松模様のマスクでもかけるか。それでも番号復元パート難しそうだな。縞模様にするとかもアリかもしれないが、うーん……。復元パートにも誤り訂正を仕込んでおくとか？そんなことできるのか？

全体の番号が完璧に復元できなくても、断片的にちゃんとなっていれば読み取れるという考え方もあるな。小さいブロックをたくさん作ってそれぞれについて情報を埋め込んでおき、誤り訂正不可能なものは破棄した上で多数決で決めるとか。情報の埋め方も単純にrow-majorとかでやると頂点1つが壊れたときに全部崩壊するので、これもQRコード等を参考に配置を考えた方が良さそう。

bitDPって言ったけど冷静に考えると過去k個の情報を持たなきゃいけないから計算量的にキツいな。焼きなましか……。AHC011（スライドパズル回）のように、解の候補をいくつか持っておく戦略が使えるかも。

## 2日目（土）

とりあえず輪っか状に繋いでグラフの番号の復元だけ試みてみる。うーん結構厳しいな。2-optだとノイズがなくても結構失敗する。順列全探索の方が良いか？でもサイズ的に厳しいんだよなあ。1ケース100クエリあるのが痛くて、8!とか9!とかで限界が来そう。低エラー率ならなんとかなるのだが……。

8!じゃないと厳しいなら、8!を2つ作るという選択肢もありそう。SとTの間にたくさん辺を張って最大カットなのでbit全探索でよい。ただうまく2つに分類できないと死ぬ。分類自体は16C8で全探索できそうだが、分類をミスったら順列全探索が全滅する。

もっと素朴な方法としては辺の数で数えるという方法もある。エラー率が高くて識別すべき整数が少なければ使えるかも。

QRコードの符号化・複合について勉強して、誤りを修正できるかたまりがbit単位ではなくbyte単位になっていそうということが分かった。これ条件キツくないか。今回の条件だとうまく行かなさそう。うーん……。

グラフ番号を無視してクラスタを作るという手もあるかもしれない。大中小のクラスタを作ってk進数っぽくやるとか。6x3+10x3+14x3+18x2+22x2で使用頂点数100、108通りを分類できる。今のところはこれが有望かなあ。どうやってデコードするかを考えなければ。

ビジュアライザでグラフ番号を出力する機能があるのが気になるが、ミスリードの可能性もあるし何とも言えない。一応そちらも考えてはおくが……。

クラスタリングどうしよ。Newmanアルゴリズムという貪欲ベースのボトムアップ法があるらしいが、まあ焼くかなあ……。

解表現

- 各頂点がどのクラスタに属するか

スコア

- 辺の有無 (1/-1) * 同じクラスタにいるかどうか (1/-1) の和

近傍

- ある頂点を別のクラスタに編入する
- ある頂点をクラスタから独立させる
- あるクラスタを別のクラスタと合体させる
- あるクラスタを2つに分離する

とか？合体はともかく分離は難しいのだが、まあ適当にクラスタ内の2点をランダムに選んでsource/sinkとして最小カットとかすれば焼きなまし中に使えなくもないか。燃やす埋めるに落とせないかと思ったけど厳しいな。

いやそもそも嘘フローな気もしてきた。まあちょっとくらい嘘でもええか。焼きなましだし。明$$日ゆっくり考える。

## 3日目（日）

2つに分けるやつ、普通に最大カット問題です。本当にありがとうございました。

最大カット、何か近似解法なかったっけと思って[例の本](https://amzn.to/3UzChGX)を引っ張り出してきた。乱択使わない適当山登りでそれなりに良い解（2-近似）が出るらしい。計算量はO(|E||V|)。

k進数？で考えたとき、全bitを使うのでなければグラフサイズをケチれることに気付いた。7x5+12x3+17x2+22x2+27x2は一見118頂点必要に見えるが、0から99までの整数を判別するだけなら96頂点で済む。最小ビットの判別が難しそうな問題はこれである程度緩和されそう。

夕方くらいに実装完了。が、弱い。クリークが大きいとそれなりにロバストなのだが、小さいとすぐに崩れてしまう。ε=0.2くらいでかなりキツい。提出はしてみたが、1位の1/10くらいの点数にしかならない。クリークのサイズをいじったりεが大きいときは全部識別するのを諦めてmod Xでの識別に切り替えたりしたが、うーん……。

試行錯誤に時間がかかるのが辛いな。部品ごとに実証できるものならいいが、今回のように全体のシステムとして完成しないと性能が分からないものは手を動かさざるを得ない。

一旦シンプルなエンコーダ／デコーダも考えてみる。単純に辺の数だけで識別するやつを作る。ノイズが乗ったあとの辺の数の期待値と分散は二項分布から分かるので、3σくらいのマージンを取ってNを決める。Mとεが小さいときに使えたら良いなと思ったが、予想以上に弱かった。ε=0.01くらいで既にクリーク版と良い勝負になる。まあ全く役に立たないわけではないので残しておくか……。

初日スタートダッシュ勢がより高い点を取っているので、何かもっと実装が簡単なものがありそうなものだが……。

2進数で考えられない？1-1を1、1-2/2-2を2、1-3/2-3/3-3を4とするような……。

i < jとなる(i, j)の組について、辺が張られていれば+1、貼られていなければ-1として行ごとに集計し、その2乗をスコアとするか。全部+1に寄せたくなるか-1に寄せたくなるかしてくれるはず。

とりあえず雑に焼きなますところだけやってみた。ε=0.25を超えたあたりから怪しくなりはじめて、ε=0.3あたりはかなり破綻している。数回やってアンサンブルするとちょっとマシになる。

まあ今までのやつよりはだいぶ良い。今まではε=0.2で成功率半々とかだったし。隣接行列の対角成分以外もちゃんと使っているのが大きいか。明日はこれの実装をしよう。

境界の行はやや信用できないから適当に按分するのもアリかもしれない。メモ。

## 4日目（月）

復元後のグラフに画像フィルタ処理とかを行っても面白いかもしれない。また完全な01情報ではなく、曖昧な値にするのもアリかもしれない。NNに画像を食わせるのもアリかもしれない。
