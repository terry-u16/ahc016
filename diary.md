# AHC016日記

## 1日目（金）

HTTF、開幕……。

<https://twitter.com/terry_u16/status/1591005266845532160>

一足遅れて問題を読む。え、めっちゃくちゃ面白そうな問題。

情報の復元、なるほど……。どうせ最終的には上位陣はほぼ全問正解当たり前で、グラフのサイズを小さくするゲームになりそう。

適当にランダム性に任せてなんやかんやする方針はうまく行かなさそう。誤り訂正と聞いてパッと思い浮かぶのはQRコード。グラフを送る問題だが、2次元白黒画像の上三角行列（？）を送る問題と考えた方が良さそう。

グラフの番号が分からなくなるやつはどうしよう。順列全探索？bitDP？Nが小さい場合はうまく行きそう。Nが大きい場合はちょっと考える必要がある。例えばグラフを一直線に繋いでおくとか？冗長性がないと1エラーで即死するので何重かに繋いでおくか。円形に繋いでおいても良い。どこが起点になるか・どちら向きかが分からないが、誤り訂正パートで起点と向きを全探索して一番それらしいものを選べばなんとかなりそう。

番号を復元するときはビムサでも焼きなましでも。焼きなましの方が良いか。2-optが使えたりする？TSPっぽくも見えてきたな。TSPならbitDPと繋がるのも納得。とはいえ誤り復元でやるならかなり高精度で復元できないと厳しいな。bitDPでいけるならそっちがいいが、それでもビットパターンによっては変な復元になることもありそう。QRコードを真似してマスクをかけ、変なビットパターンにならないようにしてあげる必要もあるかも。

ゲノコンにも通じるところがありそう。あのときも読み取りエラーが含まれていたが、最大カットがうまく行った。今回はエラー率4割とかいう激ヤバテストケースも含まれてくるが、どうなるか……。

どんなテストケースが多く含まれるか考える。テストケースの分布が対数的ではなく一様分布なので、Mやεの大きいケースを狙った方が良さそう。もっとも最終的には全部詰めていく必要がありそうだが。

誤り訂正をちゃんとやるなら[ガロア体](https://static.chunichi.co.jp/chunichi/pages/feature/science/galois_field_in_auto_factory.html)とかちゃんとやるべきだろうけど、一気に理解するにはちょっと重い。例えば1の場合は1をk個、0の場合は0をk個並べるとかでもまあとりあえずは機能しそうで、まずはここからやるか。1が連続すると番号復元パートでうまく行かなくなりそうなので、(i+j) mod 2とかで市松模様のマスクでもかけるか。それでも番号復元パート難しそうだな。縞模様にするとかもアリかもしれないが、うーん……。復元パートにも誤り訂正を仕込んでおくとか？そんなことできるのか？

全体の番号が完璧に復元できなくても、断片的にちゃんとなっていれば読み取れるという考え方もあるな。小さいブロックをたくさん作ってそれぞれについて情報を埋め込んでおき、誤り訂正不可能なものは破棄した上で多数決で決めるとか。情報の埋め方も単純にrow-majorとかでやると頂点1つが壊れたときに全部崩壊するので、これもQRコード等を参考に配置を考えた方が良さそう。

bitDPって言ったけど冷静に考えると過去k個の情報を持たなきゃいけないから計算量的にキツいな。焼きなましか……。AHC011（スライドパズル回）のように、解の候補をいくつか持っておく戦略が使えるかも。

## 2日目（土）

とりあえず輪っか状に繋いでグラフの番号の復元だけ試みてみる。うーん結構厳しいな。2-optだとノイズがなくても結構失敗する。順列全探索の方が良いか？でもサイズ的に厳しいんだよなあ。1ケース100クエリあるのが痛くて、8!とか9!とかで限界が来そう。低エラー率ならなんとかなるのだが……。

8!じゃないと厳しいなら、8!を2つ作るという選択肢もありそう。SとTの間にたくさん辺を張って最大カットなのでbit全探索でよい。ただうまく2つに分類できないと死ぬ。分類自体は16C8で全探索できそうだが、分類をミスったら順列全探索が全滅する。

もっと素朴な方法としては辺の数で数えるという方法もある。エラー率が高くて識別すべき整数が少なければ使えるかも。

QRコードの符号化・複合について勉強して、誤りを修正できるかたまりがbit単位ではなくbyte単位になっていそうということが分かった。これ条件キツくないか。今回の条件だとうまく行かなさそう。うーん……。

グラフ番号を無視してクラスタを作るという手もあるかもしれない。大中小のクラスタを作ってk進数っぽくやるとか。6x3+10x3+14x3+18x2+22x2で使用頂点数100、108通りを分類できる。今のところはこれが有望かなあ。どうやってデコードするかを考えなければ。

ビジュアライザでグラフ番号を出力する機能があるのが気になるが、ミスリードの可能性もあるし何とも言えない。一応そちらも考えてはおくが……。

クラスタリングどうしよ。Newmanアルゴリズムという貪欲ベースのボトムアップ法があるらしいが、まあ焼くかなあ……。

解表現

- 各頂点がどのクラスタに属するか

スコア

- 辺の有無 (1/-1) * 同じクラスタにいるかどうか (1/-1) の和

近傍

- ある頂点を別のクラスタに編入する
- ある頂点をクラスタから独立させる
- あるクラスタを別のクラスタと合体させる
- あるクラスタを2つに分離する

とか？合体はともかく分離は難しいのだが、まあ適当にクラスタ内の2点をランダムに選んでsource/sinkとして最小カットとかすれば焼きなまし中に使えなくもないか。燃やす埋めるに落とせないかと思ったけど厳しいな。

いやそもそも嘘フローな気もしてきた。まあちょっとくらい嘘でもええか。焼きなましだし。明$$日ゆっくり考える。

## 3日目（日）

2つに分けるやつ、普通に最大カット問題です。本当にありがとうございました。

最大カット、何か近似解法なかったっけと思って[例の本](https://amzn.to/3UzChGX)を引っ張り出してきた。乱択使わない適当山登りでそれなりに良い解（2-近似）が出るらしい。計算量はO(|E||V|)。

k進数？で考えたとき、全bitを使うのでなければグラフサイズをケチれることに気付いた。7x5+12x3+17x2+22x2+27x2は一見118頂点必要に見えるが、0から99までの整数を判別するだけなら96頂点で済む。最小ビットの判別が難しそうな問題はこれである程度緩和されそう。

夕方くらいに実装完了。が、弱い。クリークが大きいとそれなりにロバストなのだが、小さいとすぐに崩れてしまう。ε=0.2くらいでかなりキツい。提出はしてみたが、1位の1/10くらいの点数にしかならない。クリークのサイズをいじったりεが大きいときは全部識別するのを諦めてmod Xでの識別に切り替えたりしたが、うーん……。

試行錯誤に時間がかかるのが辛いな。部品ごとに実証できるものならいいが、今回のように全体のシステムとして完成しないと性能が分からないものは手を動かさざるを得ない。

一旦シンプルなエンコーダ／デコーダも考えてみる。単純に辺の数だけで識別するやつを作る。ノイズが乗ったあとの辺の数の期待値と分散は二項分布から分かるので、3σくらいのマージンを取ってNを決める。Mとεが小さいときに使えたら良いなと思ったが、予想以上に弱かった。ε=0.01くらいで既にクリーク版と良い勝負になる。まあ全く役に立たないわけではないので残しておくか……。

初日スタートダッシュ勢がより高い点を取っているので、何かもっと実装が簡単なものがありそうなものだが……。

2進数で考えられない？1-1を1、1-2/2-2を2、1-3/2-3/3-3を4とするような……。

i < jとなる(i, j)の組について、辺が張られていれば+1、貼られていなければ-1として行ごとに集計し、その2乗をスコアとするか。全部+1に寄せたくなるか-1に寄せたくなるかしてくれるはず。

とりあえず雑に焼きなますところだけやってみた。ε=0.25を超えたあたりから怪しくなりはじめて、ε=0.3あたりはかなり破綻している。数回やってアンサンブルするとちょっとマシになる。

まあ今までのやつよりはだいぶ良い。今まではε=0.2で成功率半々とかだったし。隣接行列の対角成分以外もちゃんと使っているのが大きいか。明日はこれの実装をしよう。

境界の行はやや信用できないから適当に按分するのもアリかもしれない。メモ。

## 4日目（月）

復元後のグラフに画像フィルタ処理とかを行っても面白いかもしれない。また完全な01情報ではなく、曖昧な値にするのもアリかもしれない。NNに画像を食わせるのもアリかもしれない。

2進数のやつ実装した。明確に良くなってはいる。相対スコアだと倍くらいになって10Bに乗った。だが1位の1/4程度の点数にしかならない。うーん難しい……。

誤り訂正符号を付け加えたら良いのではと思ってとりあえず1bit付けたが良くない。冗長性を付与した分1bitに割ける頂点数が減ったのが良くなさそう。

しかしもう実装が1800行に達している……。結構体力的にもキツいな。一方でローカルでファイル分割できるようにした（Rustのモジュールの木構造を探索して1つのファイルに全部まとめるコンソールアプリを作った）ので管理はだいぶやりやすくなった。作って良かった。

## 5日目（火）

今の解法だとうまく行かなさそうなので、ずっと実験をしていた。輪っかを作ったり市松模様にしてみたりぼかしフィルタ（？）を畳み込んだり。ぼかしフィルタはコンソール上でのビジュアライズにかなり役立ちそうだったが、肝心の解法はどれもうまく行かなさそう。

グラフに頂点番号の順序づけを行っているのだが、下手をすると普通に入れ替わってしまう。輪っか部分以外の最長路が輪っかの長さ未満でないと順序が識別できなくて壊れる。じゃあそういうグラフでどのくらいの頂点数が必要かというと、少なくとも9頂点は必要そう。これだとノイズに負けてしまう。

平面グラフなら……？とか色々考えていて、そういえばグラフの同型性判定を全然考えていなかったことに気付いた。まさに今回の問題そのものでは？隣接行列や2次元画像ばかり考えていたのはよくなかったか。

[同型性判定](https://www.momoyama-usagi.com/entry/math-risan09#i-10)について調べている。頂点・辺の数が一致して、次数の多重集合が一致して、同じ次数同士で隣接する次数の多重集合の多重集合が一致すれば良いらしい。文字にするとややこしい。ともかく辞書順ソートして頑張ればハッシュにできそう。

木だと[ハッシュを使って比較的簡単に同型判定ができる](https://blog.hamayanhamayan.com/entry/2017/02/06/233824)らしいけど、さすがに頂点数が多くなりそう。一般のグラフかなあ。

クリークを求めるときに変なことにならないか？と思ったけど、なんか大丈夫な気がしてきた。クリーク1, 2, 3が△型に繋がっているとすると全頂点間に辺が張られている（1つのデカいクリークになっている）のでどの頂点がどのクリークに入っているか見分けが付かないが、見分けが付かなくてもグラフの同型性判定を行う上では問題ないはず。

## 6日目（水）

いや冷静に考えて多項式時間でのグラフの同型性判定方法が見つかってるわけないだろ。

```text
1--2--7-8--9--4
| /          /|
|/          / |
3-10-11-12-6--5

1--2-7-8-9-10-4
| /          /|
|/          / |
3--11--12--6--5
```

とかが反例（だよね？）。まあ厳密な同型性判定ができなくても何かしらの手段で識別さえできれば良いのだが、情報伝達密度は落ちる。またもしかしたらグラフの頂点数がある整数K以下の時は常に正しいかもしれない。

実証しないといけない技術要素は、

- グラフの同型性判定
- クリークごとに固める焼きなまし

の2つ。前者は[VF2アルゴリズム](https://networkx.org/documentation/stable/reference/algorithms/isomorphism.vf2.html)というものがあるらしいが、まずは愚直に順列全探索をやってみる。頂点数がどのくらい必要になるか確認してみたい。[ABC232-C](https://atcoder.jp/contests/abc232/tasks/abc232_c)まんまの問題である。

試した。互いに同型でないグラフは4頂点で11個、5頂点で34個、6頂点で156個あるらしい。まあそんなもんか。6頂点ならまあどうにかなる範囲に見える。

焼きなましの方もやってみた。Σ_i(const×(クリークiの中で辺の張られている数))+Σ_(i, j)(|Σ(クリーク(i, j)の頂点(u, v)間で辺が張られていれば+1, そうでなければ-1)|)をスコアとした。結構頑張っている。ε=0.35くらいまでなら原型を保っていそう。あとは全く辺を張らないケースより辺を張ったケースの方が正解率が高い？グラフによって変わりうることは頭に入れておくと良いのかも。

コード書くの結構疲れるなと思って見てみたら、今回のAHCだけで実験コード含めて既に3000行近く書いていた。そりゃ疲れるわ。

VF2アルゴリズム、やってみる。参考ブログは以下。この方のグラフ記事めちゃくちゃ充実しているな。本当にありがたい……。

- [VF2 アルゴリズムの雑メモ](http://satemochi.blog.fc2.com/blog-entry-224.html)
- [グラフの同型性判定: VF2アルゴリズム](http://satemochi.blog.fc2.com/blog-entry-134.html)

## 7日目（木）

同型性判定をサボって次数の多重集合の一致だけ見た場合のグラフ数も並べておく。

|頂点数|同型性判定|次数集合だけ|
|-----|----------|-----------|
|4    |11        |11         |
|5    |34        |31         |
|6    |156       |102        |

後者でも十分良さそう。焼きなましの性能次第だけど後者を使って試行回数を上げて精度上げるというパターンもあり。

とりあえず次数集合だけのインチキ同型性判定で実装する。焼きなましも昨日は高速化をサボってΘ(N^2)にしていたが、Θ(N)に高速化。手元で実行してみているのだが、はっきり言ってめちゃくちゃ良い。seed=3など今までボロボロだったのだが、だいぶ高確率で当てられるようになった。提出すると得点が倍以上（相対22.4B）になって28位。グラフのサイズを調整してあげると相対26.6Bで16位。なんとか1ページ目に乗ることができた。長期コンテスト後半で追い上げるのは下手したら初めてなんだけど気持ちいいな。

潜伏を疑われてしまっているのだが、ただ溺れて沈んでいただけなんだよなあ。気付けば解法4つ目で、実験用コードも含めると4000行くらい書いているらしい。狂気。下手したらAHC008を超えそうな勢いである。

しかし最上位はここから得点を1.5倍くらいにしないとたどり着けないんだよなあ。大方針はそろそろこれで固めるとしても、ここからさらに改善を生やしていかないといけないのでつらい。

グラフの復元を一発勝負にしているのはなんかもったいない気がするな。複数回やって多数決とかは逆に下がったのだけれど、「どのグラフとも同型でなければ再抽選」くらいは入れていい気がする。その場合はグラフ同士の編集距離（？）を大きくした方が良いな。あとはそれでも一致しなかったら距離の近いグラフを選ぶとか……なんかやりようはありそう。とりあえずTODOキューに突っ込んでおく。

## 8日目（金）

上3人が異常な点数を取っているな。神々の戦いになっている。ヤバすぎ。

混同行列とか考えると良いかもしれない。それを作った上で混同しづらいようにグラフを選択するとか。その選択も焼きなませるはず。

さすがにインチキ同型性判定だけだとアレなので、VF2アルゴリズムを実装した。あとから気付いたが、普通に順列全探索でも間に合った説がある。テストだとなんか時間がかかっていたので厳しいかと思っていたが、テストは2^((6 * 5) / 2)=2^15個のグラフについて同型性判定していたせいだった。そりゃ時間かかるわ。アホ。まあせっかく作ったし残しておくか……。

混同行列を作る。配布されているtesterプログラムをいじってある(M, ε)の組に対して1000M回クエリを投げ、(正解, 解答)のペアをファイルに書き出すようにした。Mは11, 34, 156の3つで試す。寝ている間に頑張ってくれるはず。

焼きなまし時間を長くしたら目に見えてスコアが上がった。まあしっかり焼くの大事か……。頑張って高速化する必要があるかもしれない。bit列にしてpopcntするとまとめて数えられるかも。128bit整数を持っておいてグループごとにマスクを作り、辺のbitとandをとってpopcntでいけるな。

## 9日目（土）

popcntで焼きなましを高速化した。N=96のケースで3倍速。まあ悪くない。相対25.3B→27.0Bで29位→22位。めちゃくちゃ密集してるな。

もうちょっと高速化して当初の4倍速にした。高速化楽しい！

混同行列をseabornで可視化した。思った以上に差が出るなこれ。選び方によって「どのグラフが来ても99%以上で正解」と「ワーストケースで62%くらいしか正解しない」くらい違う。ここまでとは思っていなかったので正直予想外。昨日「生成したグラフから昇順でM個選ぶのと降順でM個選ぶのとでなんか正解率が明らかに違うな……バグか？」と思っていたのだけれど、こういうことだったのか。変わってもせいぜい1割とかそのくらいだと思っていた。面白いなこれ……！

他にも、例えば5頂点のグラフなら最大で34個の分類ができるが、これをフルに使うよりちょっと余裕を持たせた方が良いこともあることが分かった。

正解率の高いグラフから順番に選ぶようにした。思ったほど大きな効果はなかったが、相対28.5Bで18位。ついでに焼きなましの回数も1回から5回に増やして多数決を取るようにした。29.3Bで15位。ちなみにこのときymatsuxさんが41.2Bで単独トップに躍り出たので相対スコアがよく分からなくなっている。ここから3～4割増しってどうするんだ……。

精度が上がったので、εが小さいときのグラフサイズをもう少し切り詰めることができるはず。ちょっと実験してみたところそれなりに余地はありそうだが、データを取らないといけない。(M, ε, ノード数N', 冗長性R)の組について正答率を求めて、そこから二項分布でスコアの期待値を求める。全探索するととても時間がかかるので、探索範囲は適当に狭める。

ちょっと少なめだけどとりあえず各組について1000回ずつクエリを投げて集計し、一番良い戦略を選ぶようにした。相対33.9Bで8位。15%伸びたのは大きい。ただここからの伸ばし方が分からんなあ……。

混同行列を考慮するようにした。jだと思ったときに実際はiである確率が分かるので、その値を考慮して投票するようにした。相対34.6Bで7位。多分良くなってる気がするけど、テストケース数が少ないので偶然かもしれない……。

焼きなましのスコアを (クリーク内のスコア)×2+(クリーク間のスコア) にしていたのだが、この定数2をいじった方が良くなる場合があることに気付いた。これも探索対象にするか……。寝ている間に回しておく。

## 10日目（日）

あまり眠れなかった。眠い……。

昨日回していたやつの結果が出たのでこれも埋め込む。今までの解とスコアの期待値を比較するスクリプトを書いてみたところ、相対スコア（自分比）で10%ほど伸びていそう。特にεが大きい（だいたい0.35以上）ケースで相当伸びていそう。

結構上がることを期待していたが、提出するとほとんど点数は変わらず。むしろ絶対スコアだと落ちている。うーん？

もう少し見てみると、ε=0.08とかのケースでなんか前に比べて弱くなっている。なんだこれ……？調べてみたけれど原因がよく分からない。

使用するグラフをM個選ぶとき、現状は正解率の高い順にソートしてM個選んでいるけれど、組み合わせを焼いた方が良いのではないか？と思って焼いてみた。なんか全然ダメ。よく分からないけどとりあえずボツ。

ε=0.08とかのケースで弱いやつ、よくよく見てみると正解率のソート方法を安定ソートから不安定ソートに切り替えたのが原因っぽい。マジか。不安定ソートにした方がグラフがばらけて良いかなと思ったのだけれど、辺が増えてクリークごとに固めるのが難しくなるのが悪いんだろうか。戻すと確かに性能が上がってそう。安定ソートに切り替えて再度パラメータ探索を回す。

パラメータ探索を待っていたらnagissさんが突如45B点を取っていてTLがざわつく。圧倒的すぎる……。なんか機械学習系の手法を使っていたりする？

4時間くらいかかって完了。回したブランチが最新のものじゃなくて焦ったが、メイン処理は同じだったのでどうにか事無きを得る。ちゃんと確認しましょう……。

手元環境では前回提出と比べて1%弱スコアが上がった。ジャッジに投げると、絶対スコアは上がらなかったが相対スコアは0.5B点くらい伸びた。他にやることもないし、これが最終提出かな。

最終日は思った以上に抜かされなかった。潜伏勢が怖かったが、今回は特に変動もないまま暫定7位でフィニッシュ。相対評価スコア制+発想が大事な問題というのも大きかったのだろうか。

普段のマラソンは先行逃げ切りパターンばかりで、こんな感じで後半差しに行くパターンは初めてだったかもしれない。初手や二手目の解法がハズレでも粘って勝ちに行けたというのは良い収穫だったかな。

## 解説放送

wataさん、強すぎです。
